"""
Endpoints para el sistema de planes nutricionales.
"""

from typing import List, Optional, Any
from fastapi import APIRouter, Depends, HTTPException, Query, Path, Header
from sqlalchemy.orm import Session

from app.db.session import get_db
from app.core.auth0_fastapi import get_current_user, Auth0User
from app.core.tenant import verify_gym_access
from app.models.user import User
from app.models.gym import Gym
from app.schemas.nutrition import (
    NutritionPlan, NutritionPlanCreate, NutritionPlanUpdate, NutritionPlanFilters,
    NutritionPlanListResponse, NutritionPlanWithDetails, NutritionPlanListResponseHybrid,
    DailyNutritionPlan, DailyNutritionPlanCreate, DailyNutritionPlanWithMeals,
    Meal, MealCreate, MealWithIngredients, MealIngredient, MealIngredientCreate,
    NutritionPlanFollower, NutritionPlanFollowerCreate,
    UserMealCompletion, UserMealCompletionCreate,
    TodayMealPlan, UserNutritionDashboard, NutritionAnalytics, NutritionDashboardHybrid,
    NutritionGoal, DifficultyLevel, BudgetLevel, DietaryRestriction, MealType, PlanType, PlanStatus,
    ArchivePlanRequest, LivePlanStatusUpdate
)
from app.services.nutrition import NutritionService, NotFoundError, ValidationError, PermissionError
from app.services.user import user_service

router = APIRouter()


@router.get("/plans", response_model=NutritionPlanListResponse)
def list_nutrition_plans(
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user),
    page: int = Query(1, ge=1, description="N√∫mero de p√°gina para paginaci√≥n"),
    per_page: int = Query(20, ge=1, le=100, description="Elementos por p√°gina (m√°ximo 100)"),
    goal: Optional[NutritionGoal] = Query(None, description="Filtrar por objetivo nutricional (loss, gain, bulk, cut, maintain)"),
    difficulty_level: Optional[DifficultyLevel] = Query(None, description="Filtrar por nivel de dificultad (beginner, intermediate, advanced)"),
    budget_level: Optional[BudgetLevel] = Query(None, description="Filtrar por nivel de presupuesto (low, medium, high)"),
    dietary_restrictions: Optional[DietaryRestriction] = Query(None, description="Filtrar por restricciones diet√©ticas (vegetarian, vegan, gluten_free, etc.)"),
    search_query: Optional[str] = Query(None, description="Buscar por t√≠tulo o descripci√≥n del plan"),
    creator_id: Optional[int] = Query(None, description="Filtrar por ID del creador del plan"),
    plan_type: Optional[PlanType] = Query(None, description="Filtrar por tipo: template (individual), live (grupal), archived (hist√≥rico)"),
    status: Optional[PlanStatus] = Query(None, description="Filtrar por estado: not_started, running, finished"),
    is_live_active: Optional[bool] = Query(None, description="Solo planes live que est√°n actualmente activos"),
):
    """
    üìã **Listar Planes Nutricionales con Filtros Avanzados**
    
    **Descripci√≥n:**
    Obtiene una lista paginada de planes nutricionales del gimnasio con m√∫ltiples filtros.
    Incluye soporte completo para el sistema h√≠brido (template, live, archived).
    
    **Casos de Uso:**
    - üì± Pantalla principal de planes disponibles
    - üîç B√∫squeda y filtrado de planes por caracter√≠sticas
    - üë• Ver planes creados por entrenadores espec√≠ficos
    - üéØ Encontrar planes seg√∫n objetivos personales
    - ‚ö° Mostrar solo planes live activos para unirse
    
    **Filtros Disponibles:**
    - **Tipo de Plan:** template (individual), live (sincronizado), archived (hist√≥rico)
    - **Estado:** not_started (no iniciado), running (activo), finished (terminado)
    - **Objetivo:** loss (p√©rdida), gain (ganancia), bulk (volumen), cut (definici√≥n)
    - **Dificultad:** beginner, intermediate, advanced
    - **Presupuesto:** low, medium, high
    - **Restricciones:** vegetarian, vegan, gluten_free, dairy_free, etc.
    
    **Permisos:**
    - ‚úÖ Cualquier miembro del gimnasio puede ver planes p√∫blicos
    - ‚úÖ Creadores pueden ver sus propios planes privados
    - ‚úÖ Seguidores pueden ver planes privados que siguen
    
    **Paginaci√≥n:**
    - P√°gina por defecto: 1
    - Elementos por p√°gina: 20 (m√°ximo 100)
    - Metadatos incluidos: has_next, has_prev, total
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "plans": [
        {
          "id": 1,
          "title": "Plan de P√©rdida de Peso - 30 d√≠as",
          "plan_type": "template",
          "status": "running",
          "current_day": 15,
          "total_followers": 87
        }
      ],
      "total": 150,
      "page": 1,
      "per_page": 20,
      "has_next": true,
      "has_prev": false
    }
    ```
    """
    service = NutritionService(db)
    
    # Crear filtros
    filters = NutritionPlanFilters(
        goal=goal,
        difficulty_level=difficulty_level,
        budget_level=budget_level,
        dietary_restrictions=dietary_restrictions,
        search_query=search_query,
        creator_id=creator_id,
        plan_type=plan_type,
        status=status,
        is_live_active=is_live_active
    )
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    plans, total = service.list_nutrition_plans(
        gym_id=current_gym.id,
        filters=filters,
        page=page,
        per_page=per_page,
        user_id=db_user.id
    )
    
    return NutritionPlanListResponse(
        plans=plans,
        total=total,
        page=page,
        per_page=per_page,
        has_next=(page * per_page) < total,
        has_prev=page > 1
    )


@router.post("/plans", response_model=NutritionPlan)
def create_nutrition_plan(
    plan_data: NutritionPlanCreate,
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    ‚ûï **Crear Nuevo Plan Nutricional**
    
    **Descripci√≥n:**
    Crea un plan nutricional vac√≠o que luego se puede llenar con d√≠as y comidas.
    Soporte completo para los 3 tipos del sistema h√≠brido.
    
    **Tipos de Planes:**
    - üìã **Template:** Plan individual, cada usuario lo inicia cuando quiere
    - üî¥ **Live:** Plan grupal sincronizado, fecha de inicio fija para todos
    - üìö **Archived:** Plan hist√≥rico creado autom√°ticamente desde lives terminados
    
    **Campos Requeridos:**
    - `title`: Nombre del plan (m√°ximo 200 caracteres)
    - `goal`: Objetivo nutricional (loss, gain, bulk, cut, maintain)
    - `duration_days`: Duraci√≥n en d√≠as (1-365)
    - `plan_type`: Tipo de plan (template, live, archived)
    
    **Campos Espec√≠ficos por Tipo:**
    - **Live Plans:** Requieren `live_start_date`
    - **Template/Archived:** `live_start_date` debe ser null
    
    **Permisos:**
    - üë®‚Äç‚öïÔ∏è Solo entrenadores y administradores pueden crear planes
    - ‚úÖ Autom√°ticamente asigna al usuario como creador
    
    **Proceso de Creaci√≥n:**
    1. Crear plan b√°sico ‚û°Ô∏è 
    2. Agregar d√≠as (`POST /plans/{id}/days`) ‚û°Ô∏è 
    3. Agregar comidas (`POST /days/{id}/meals`) ‚û°Ô∏è 
    4. Agregar ingredientes (`POST /meals/{id}/ingredients`)
    
    **Validaciones Autom√°ticas:**
    - Verificaci√≥n de permisos de usuario
    - Validaci√≥n de fechas para planes live
    - Conversi√≥n autom√°tica de tags a JSON
    - Asignaci√≥n de gym_id del contexto actual
    
    **Ejemplo de Request:**
    ```json
    {
      "title": "Plan Detox 21 d√≠as",
      "description": "Plan de limpieza corporal",
      "goal": "loss",
      "difficulty_level": "beginner",
      "plan_type": "live",
      "duration_days": 21,
      "live_start_date": "2024-02-01T00:00:00Z",
      "target_calories": 1500,
      "is_public": true,
      "tags": ["detox", "principiante"]
    }
    ```
    
    **C√≥digos de Error:**
    - `400`: Datos inv√°lidos o validaci√≥n fallida
    - `403`: Sin permisos para crear planes
    - `404`: Usuario no encontrado
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        # Usar el m√©todo espec√≠fico para planes live o el m√©todo base
        if plan_data.plan_type == PlanType.LIVE:
            plan = service.create_live_nutrition_plan(
                plan_data=plan_data,
                creator_id=db_user.id,
                gym_id=current_gym.id
            )
        else:
            plan = service.create_nutrition_plan(
                plan_data=plan_data,
                creator_id=db_user.id,
                gym_id=current_gym.id
            )
        return plan
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.get("/plans/{plan_id}", response_model=NutritionPlanWithDetails)
def get_nutrition_plan(
    plan_id: int = Path(..., description="ID √∫nico del plan nutricional"),
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    üìñ **Obtener Plan Nutricional Completo**
    
    **Descripci√≥n:**
    Obtiene un plan nutricional con toda su informaci√≥n detallada incluyendo:
    d√≠as, comidas, ingredientes y metadatos del sistema h√≠brido.
    
    **Informaci√≥n Incluida:**
    - üìã **Plan Base:** T√≠tulo, descripci√≥n, objetivos, duraci√≥n, tipo
    - üìÖ **D√≠as Completos:** Todos los d√≠as del plan (1 a N)
    - üçΩÔ∏è **Meals Detalladas:** Comidas de cada d√≠a con ingredientes
    - üßÆ **Informaci√≥n Nutricional:** Calor√≠as, prote√≠nas, carbos, grasas
    - üìä **Metadatos H√≠bridos:** Estado actual, d√≠a en curso, participantes
    - üë§ **Info del Creador:** Nombre del entrenador que lo cre√≥
    - ‚úÖ **Estado del Usuario:** Si el usuario actual lo est√° siguiendo
    
    **Control de Acceso:**
    - ‚úÖ **Planes P√∫blicos:** Cualquier miembro puede verlos
    - üîí **Planes Privados:** Solo creador y seguidores activos
    - üë®‚Äç‚öïÔ∏è **Creadores:** Acceso total a sus propios planes
    - üë• **Seguidores:** Acceso si est√°n siguiendo activamente
    
    **Informaci√≥n por Tipo de Plan:**
    - **Template:** Informaci√≥n est√°tica, disponible siempre
    - **Live:** Estado actualizado en tiempo real, participantes actuales
    - **Archived:** Plan hist√≥rico con datos originales preservados
    
    **Casos de Uso:**
    - üì± Pantalla de detalles del plan
    - üìù Vista previa antes de seguir un plan
    - üîç Navegaci√≥n completa del contenido
    - üìä An√°lisis nutricional detallado
    - üçΩÔ∏è Planificaci√≥n de comidas y compras
    
    **Estructura de Respuesta:**
    ```json
    {
      "id": 1,
      "title": "Plan Detox 21 d√≠as",
      "plan_type": "live",
      "current_day": 5,
      "status": "running",
      "live_participants_count": 87,
      "daily_plans": [
        {
          "id": 1,
          "day_number": 1,
          "total_calories": 1500,
          "meals": [
            {
              "id": 1,
              "meal_type": "breakfast",
              "name": "Batido Verde",
              "calories": 250,
              "ingredients": [...]
            }
          ]
        }
      ],
      "creator_name": "Dr. Mart√≠nez",
      "is_followed_by_user": true
    }
    ```
    
    **C√≥digos de Error:**
    - `403`: Sin permisos para ver este plan privado
    - `404`: Plan no encontrado o no pertenece al gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        plan = service.get_nutrition_plan_with_details(plan_id, current_gym.id, db_user.id)
        return plan
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except PermissionError as e:
        raise HTTPException(status_code=403, detail=str(e))


@router.post("/plans/{plan_id}/follow", response_model=NutritionPlanFollower)
def follow_nutrition_plan(
    plan_id: int = Path(..., description="ID del plan nutricional a seguir"),
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    ‚úÖ **Seguir Plan Nutricional**
    
    **Descripci√≥n:**
    Permite al usuario empezar a seguir un plan nutricional espec√≠fico.
    El comportamiento var√≠a seg√∫n el tipo de plan del sistema h√≠brido.
    
    **Comportamiento por Tipo:**
    - üìã **Template:** Usuario inicia inmediatamente, progreso individual
    - üî¥ **Live:** Usuario se une al plan grupal, progreso sincronizado
    - üìö **Archived:** Usuario inicia como template, usando contenido archivado
    
    **Proceso de Seguimiento:**
    1. **Validaci√≥n:** Verifica que el plan existe y es accesible
    2. **Check Duplicados:** Evita seguir el mismo plan dos veces
    3. **Registro:** Crea entrada en NutritionPlanFollower
    4. **Configuraci√≥n:** Establece notificaciones y preferencias
    5. **Inicio:** Determina fecha de inicio seg√∫n tipo de plan
    
    **Configuraciones Incluidas:**
    - üîî **Notificaciones:** Habilitadas por defecto
    - ‚è∞ **Horarios Default:**
      - Desayuno: 08:00
      - Almuerzo: 13:00
      - Cena: 20:00
    - üìÖ **Fecha Inicio:** 
      - Template/Archived: Inmediata (hoy)
      - Live: Fecha global del plan
    
    **Estados Posibles:**
    - **Template/Archived:** Inicia inmediatamente como "running"
    - **Live (futuro):** Estado "not_started" hasta fecha de inicio
    - **Live (activo):** Inicia inmediatamente sincronizado
    - **Live (terminado):** No se puede seguir
    
    **Validaciones:**
    - ‚úÖ Plan existe y pertenece al gimnasio
    - ‚úÖ Usuario no est√° siguiendo ya este plan
    - ‚úÖ Plan es p√∫blico o usuario tiene acceso
    - ‚úÖ Plan live no est√° terminado
    
    **Casos de Uso:**
    - üéØ Unirse a un plan personal (template)
    - üë• Participar en challenge grupal (live)
    - üìö Usar plan de √©xito pasado (archived)
    - üîÑ Reactivar plan que se hab√≠a dejado
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "id": 123,
      "user_id": 456,
      "plan_id": 789,
      "is_active": true,
      "start_date": "2024-01-15T00:00:00Z",
      "notifications_enabled": true,
      "notification_time_breakfast": "08:00",
      "notification_time_lunch": "13:00",
      "notification_time_dinner": "20:00"
    }
    ```
    
    **C√≥digos de Error:**
    - `400`: Ya sigues este plan o plan no disponible
    - `404`: Plan no encontrado
    - `403`: Sin acceso a plan privado
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        follower = service.follow_nutrition_plan(
            plan_id=plan_id,
            user_id=db_user.id,
            gym_id=current_gym.id
        )
        return follower
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.delete("/plans/{plan_id}/follow")
def unfollow_nutrition_plan(
    plan_id: int = Path(..., description="ID del plan nutricional a dejar de seguir"),
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    ‚ùå **Dejar de Seguir Plan Nutricional**
    
    **Descripci√≥n:**
    Permite al usuario dejar de seguir un plan nutricional activo.
    Los datos de progreso se conservan pero se marca como inactivo.
    
    **Proceso de Desvinculaci√≥n:**
    1. **Validaci√≥n:** Verifica que el usuario est√© siguiendo el plan
    2. **Soft Delete:** Marca como `is_active = false`
    3. **Fecha Fin:** Establece `end_date` como timestamp actual
    4. **Preservaci√≥n:** Mantiene historial de progreso y completaciones
    5. **Notificaciones:** Desactiva autom√°ticamente las notificaciones
    
    **Datos Preservados:**
    - üìä **Progreso Hist√≥rico:** Todas las meals completadas
    - üìà **Estad√≠sticas:** Porcentajes de completaci√≥n por d√≠a
    - üì∏ **Fotos de Comidas:** URLs de im√°genes subidas
    - ‚≠ê **Calificaciones:** Ratings de satisfacci√≥n dados
    - üí¨ **Notas Personales:** Comentarios en completaciones
    
    **Implicaciones por Tipo:**
    - **Template:** Pausa progreso individual, puede retomar despu√©s
    - **Live:** Se sale del challenge grupal, no afecta a otros
    - **Archived:** Detiene seguimiento del plan hist√≥rico
    
    **Reactivaci√≥n Posterior:**
    - ‚úÖ Usuario puede volver a seguir el mismo plan m√°s tarde
    - üîÑ Se crea nueva entrada en NutritionPlanFollower
    - üìÖ Nuevo `start_date` si vuelve a seguirlo
    - üìä Progreso anterior permanece en historial
    
    **Casos de Uso:**
    - üõë Pausar plan temporalmente
    - üîÑ Cambiar a un plan diferente
    - üòî Abandono por dificultad o falta de tiempo
    - ‚úÖ Completar plan exitosamente
    
    **Validaciones:**
    - ‚úÖ Plan existe y pertenece al gimnasio
    - ‚úÖ Usuario est√° actualmente siguiendo el plan
    - ‚úÖ Entrada de seguimiento est√° activa
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "success": true
    }
    ```
    
    **An√°lisis de Abandono:**
    - üìä Los datos quedan disponibles para analytics del creador
    - üìà M√©tricas de retenci√≥n y engagement
    - üéØ Identificaci√≥n de puntos de abandono comunes
    - üí° Insights para mejorar futuros planes
    
    **C√≥digos de Error:**
    - `404`: No est√°s siguiendo este plan actualmente
    - `404`: Plan no encontrado en este gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        success = service.unfollow_nutrition_plan(
            plan_id=plan_id,
            user_id=db_user.id,
            gym_id=current_gym.id
        )
        return {"success": success}
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.post("/meals/{meal_id}/complete", response_model=UserMealCompletion)
def complete_meal(
    completion_data: UserMealCompletionCreate,
    meal_id: int = Path(..., description="ID √∫nico de la comida a completar"),
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    ‚úÖ **Completar Comida (Tracking Central)**
    
    **Descripci√≥n:**
    Marca una comida espec√≠fica como completada por el usuario.
    Endpoint fundamental para el tracking y analytics del sistema.
    
    **Proceso de Completaci√≥n:**
    1. **Validaci√≥n:** Verifica que la comida existe y usuario sigue el plan
    2. **Check Duplicados:** Evita completar la misma comida dos veces
    3. **Registro:** Crea entrada en UserMealCompletion con timestamp
    4. **Analytics:** Actualiza progreso diario autom√°ticamente
    5. **Notificaciones:** Trigger para celebraciones y logros
    
    **Datos Opcionales Incluidos:**
    - ‚≠ê **satisfaction_rating:** Calificaci√≥n 1-5 de qu√© tan rica estuvo
    - üì∏ **photo_url:** URL de foto de la comida preparada
    - üí¨ **notes:** Comentarios personales del usuario
    - üïí **completed_at:** Timestamp autom√°tico de completaci√≥n
    
    **Validaciones Autom√°ticas:**
    - ‚úÖ La comida pertenece a un plan que el usuario est√° siguiendo
    - ‚úÖ El usuario est√° activamente siguiendo ese plan
    - ‚úÖ La comida no ha sido completada previamente
    - ‚úÖ La comida pertenece al gimnasio correcto
    
    **Impacto en el Sistema:**
    - üìä **Progreso Diario:** Se recalcula el porcentaje del d√≠a
    - üéØ **Streaks:** Actualiza rachas de completaci√≥n
    - üìà **Analytics:** Contribuye a m√©tricas del plan
    - üèÜ **Gamificaci√≥n:** Puede disparar logros o badges
    
    **Ejemplo de Request:**
    ```json
    {
      "satisfaction_rating": 5,
      "photo_url": "https://example.com/my-meal.jpg",
      "notes": "Estuvo deliciosa, muy f√°cil de preparar"
    }
    ```
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "id": 789,
      "user_id": 123,
      "meal_id": 456,
      "satisfaction_rating": 5,
      "photo_url": "https://example.com/my-meal.jpg",
      "notes": "Estuvo deliciosa, muy f√°cil de preparar",
      "completed_at": "2024-01-15T12:30:00Z",
      "created_at": "2024-01-15T12:30:00Z"
    }
    ```
    
    **Casos de Uso:**
    - ‚úÖ Check diario de comidas consumidas
    - üì∏ Compartir progreso con fotos
    - ‚≠ê Feedback para mejorar futuras comidas
    - üìä Tracking personal de adherencia
    - üë• Participaci√≥n en challenges grupales
    
    **Metrics Calculadas:**
    - üìà **Completion Rate:** % de comidas completadas vs planeadas
    - üî• **Current Streak:** D√≠as consecutivos cumpliendo metas
    - ‚≠ê **Average Rating:** Satisfacci√≥n promedio con el plan
    - üìÖ **Daily Progress:** Progreso del d√≠a actual (0-100%)
    
    **Informaci√≥n para Creadores:**
    - üìä Los datos an√≥nimos contribuyen a analytics del plan
    - ‚≠ê Ratings ayudan a identificar comidas populares
    - üì∏ Fotos pueden inspirar a otros usuarios
    - üí¨ Comentarios revelan insights de mejora
    
    **C√≥digos de Error:**
    - `400`: Comida ya completada anteriormente
    - `400`: No est√°s siguiendo el plan que contiene esta comida
    - `404`: Comida no encontrada o no pertenece al gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        completion = service.complete_meal(
            meal_id=meal_id,
            user_id=db_user.id,
            gym_id=current_gym.id,
            satisfaction_rating=completion_data.satisfaction_rating,
            photo_url=completion_data.photo_url,
            notes=completion_data.notes
        )
        return completion
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.get("/today", response_model=TodayMealPlan)
def get_today_meal_plan(
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    üçΩÔ∏è **Plan de Comidas de HOY (L√≥gica H√≠brida)**
    
    **Descripci√≥n:**
    Endpoint m√°s usado del sistema. Obtiene las comidas espec√≠ficas que el usuario
    debe consumir HOY, con l√≥gica inteligente seg√∫n el tipo de plan.
    
    **L√≥gica de C√°lculo del D√≠a Actual:**
    - üìã **Template/Archived:** D√≠a basado en cu√°ndo empez√≥ el usuario individualmente
    - üî¥ **Live:** D√≠a basado en fecha global compartida por todos los usuarios
    - üïí **C√°lculo:** `current_day = d√≠as_transcurridos + 1`
    
    **Ejemplos de C√°lculo:**
    ```
    Template Plan:
    - Usuario empez√≥: 1 enero
    - Hoy: 15 enero  
    - current_day = (15-1) + 1 = 15
    - Devuelve: Comidas del D√≠a 15
    
    Live Plan:
    - Plan empez√≥: 1 febrero (para todos)
    - Hoy: 5 febrero
    - current_day = (5-1) + 1 = 5  
    - Devuelve: Comidas del D√≠a 5 (todos ven lo mismo)
    ```
    
    **Estados Posibles:**
    - ‚úÖ **running:** Plan activo, devuelve comidas del d√≠a actual
    - ‚è≥ **not_started:** Plan live futuro, devuelve `meals: []` y d√≠as restantes
    - üèÅ **finished:** Plan terminado, busca pr√≥ximo plan activo
    
    **Informaci√≥n Incluida:**
    - üçΩÔ∏è **Meals Completas:** Desayuno, almuerzo, cena con ingredientes
    - üìä **Progreso:** Porcentaje de comidas completadas hoy (0-100%)
    - üéØ **Plan Context:** Informaci√≥n del plan que se est√° siguiendo
    - üìÖ **Metadatos:** D√≠a actual, estado, d√≠as hasta inicio (si aplica)
    
    **Casos de Respuesta:**
    
    **1. Plan Activo con Comidas:**
    ```json
    {
      "date": "2024-01-15",
      "current_day": 15,
      "status": "running",
      "plan": {
        "id": 123,
        "title": "Plan P√©rdida Peso",
        "plan_type": "template"
      },
      "meals": [
        {
          "id": 456,
          "meal_type": "breakfast",
          "meal_name": "Avena con Frutas",
          "calories": 350,
          "ingredients": [...]
        }
      ],
      "completion_percentage": 33.3
    }
    ```
    
    **2. Plan Live Pr√≥ximo a Empezar:**
    ```json
    {
      "date": "2024-01-15",
      "current_day": 0,
      "status": "not_started", 
      "days_until_start": 7,
      "plan": {
        "id": 789,
        "title": "Challenge Detox",
        "plan_type": "live"
      },
      "meals": []
    }
    ```
    
    **3. Sin Planes Activos:**
    ```json
    {
      "date": "2024-01-15",
      "current_day": 0,
      "status": "not_started",
      "meals": []
    }
    ```
    
    **Casos de Uso:**
    - üì± Pantalla principal de la app nutricional
    - üîî Notificaciones push con comidas del d√≠a
    - ‚úÖ Lista de pendientes diarios
    - üìä Dashboard de progreso
    - üçΩÔ∏è Widget de "comidas de hoy"
    
    **Optimizaciones:**
    - üîÑ Actualizaci√≥n autom√°tica de estados live
    - üì¶ Carga eficiente con selectinload
    - üéØ B√∫squeda inteligente de plan activo
    - ‚ö° Cache-friendly para llamadas frecuentes
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    # Usar la nueva l√≥gica h√≠brida
    meal_plan = service.get_hybrid_today_meal_plan(
        user_id=db_user.id,
        gym_id=current_gym.id
    )
    
    return meal_plan


@router.get("/dashboard", response_model=NutritionDashboardHybrid)
def get_nutrition_dashboard(
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    üìä **Dashboard Nutricional H√≠brido**
    
    **Descripci√≥n:**
    Vista unificada del estado nutricional completo del usuario.
    Organiza planes por categor√≠as y muestra m√©tricas de progreso.
    
    **Categorizaci√≥n Inteligente:**
    - üìã **Template Plans:** Planes individuales que el usuario est√° siguiendo
    - üî¥ **Live Plans:** Challenges grupales activos o pr√≥ximos
    - üìö **Available Plans:** Planes p√∫blicos disponibles para unirse
    - üçΩÔ∏è **Today Plan:** Plan espec√≠fico de comidas para hoy
    
    **Informaci√≥n por Categor√≠a:**
    
    **Template Plans:**
    - Planes personales en progreso
    - Progreso individual por usuario
    - current_day basado en fecha de inicio individual
    - Estado: running, finished seg√∫n duraci√≥n personal
    
    **Live Plans:**
    - Challenges con fechas sincronizadas
    - Contador de participantes en tiempo real
    - current_day basado en fecha global del plan
    - Estados: not_started, running, finished (para todos igual)
    
    **Available Plans:**
    - Planes p√∫blicos del gimnasio que no sigue
    - Preview de contenido y caracter√≠sticas
    - Informaci√≥n para decidir si unirse
    - Filtrados por relevancia y popularidad
    
    **Today Plan:**
    - Comidas espec√≠ficas para HOY
    - Progreso de completaci√≥n del d√≠a actual
    - Informaci√≥n del plan activo
    - Llamadas a acci√≥n pendientes
    
    **M√©tricas Incluidas:**
    - üî• **Completion Streak:** D√≠as consecutivos cumpliendo objetivos
    - üìà **Weekly Progress:** Progreso de los √∫ltimos 7 d√≠as
    - üéØ **Today Progress:** % de comidas completadas hoy
    - üìä **Plan Status:** Estado actualizado de cada plan
    
    **Estructura de Respuesta:**
    ```json
    {
      "template_plans": [
        {
          "id": 123,
          "title": "Mi Plan Personal",
          "plan_type": "template",
          "current_day": 15,
          "status": "running",
          "completion_percentage": 85.5
        }
      ],
      "live_plans": [
        {
          "id": 456,
          "title": "Challenge Detox",
          "plan_type": "live", 
          "current_day": 5,
          "status": "running",
          "live_participants_count": 87,
          "days_until_start": 0
        }
      ],
      "available_plans": [
        {
          "id": 789,
          "title": "Plan Masa Muscular",
          "plan_type": "template",
          "total_followers": 150,
          "avg_satisfaction": 4.8
        }
      ],
      "today_plan": {
        "date": "2024-01-15",
        "current_day": 5,
        "status": "running",
        "meals": [...],
        "completion_percentage": 66.7
      },
      "completion_streak": 7,
      "weekly_progress": [...]
    }
    ```
    
    **Casos de Uso:**
    - üì± Pantalla principal de la secci√≥n nutrition
    - üëÅÔ∏è Vista r√°pida del estado general
    - üéØ Identificar tareas pendientes del d√≠a
    - üìä Monitorear progreso semanal
    - üîç Descubrir nuevos planes disponibles
    
    **Optimizaciones:**
    - üîÑ Estados actualizados en tiempo real para planes live
    - üì¶ Carga eficiente de datos relacionados
    - üéØ Filtrado inteligente de planes relevantes
    - ‚ö° Agregaci√≥n optimizada de m√©tricas
    
    **Personalizaci√≥n:**
    - Orden por relevancia personal
    - Planes recomendados seg√∫n historial
    - M√©tricas adaptadas a objetivos del usuario
    - Filtros autom√°ticos de contenido apropiado
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    dashboard = service.get_hybrid_dashboard(
        user_id=db_user.id,
        gym_id=current_gym.id
    )
    
    return dashboard


# ===== ENDPOINTS PARA CREADORES DE CONTENIDO =====

@router.post("/plans/{plan_id}/days", response_model=DailyNutritionPlan)
def create_daily_plan(
    daily_plan_data: DailyNutritionPlanCreate,
    plan_id: int = Path(..., description="ID del plan nutricional al que agregar el d√≠a"),
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    üìÖ **Crear D√≠a de Plan Nutricional (Para Creadores)**
    
    **Descripci√≥n:**
    Permite a entrenadores y creadores agregar un d√≠a espec√≠fico a su plan nutricional.
    Cada d√≠a representa una jornada completa de comidas estructuradas.
    
    **Proceso de Creaci√≥n:**
    1. **Validaci√≥n de Permisos:** Solo el creador del plan puede agregar d√≠as
    2. **Verificaci√≥n de Secuencia:** Valida n√∫mero de d√≠a l√≥gico
    3. **Estructura Base:** Crea contenedor para las comidas del d√≠a
    4. **Informaci√≥n Nutricional:** Establece metas cal√≥ricas del d√≠a
    
    **Campos Requeridos:**
    - `day_number`: N√∫mero del d√≠a (1, 2, 3... hasta duraci√≥n del plan)
    - `nutrition_plan_id`: Debe coincidir con el {plan_id} del path
    
    **Campos Opcionales:**
    - `planned_date`: Fecha espec√≠fica (principalmente para planes live)
    - `total_calories`: Meta cal√≥rica total del d√≠a
    - `total_protein_g`: Meta de prote√≠na en gramos
    - `total_carbs_g`: Meta de carbohidratos en gramos  
    - `total_fat_g`: Meta de grasas en gramos
    - `notes`: Notas especiales para el d√≠a (hidrataci√≥n, descanso, etc.)
    
    **Validaciones Autom√°ticas:**
    - ‚úÖ Usuario es el creador del plan
    - ‚úÖ Plan existe y pertenece al gimnasio
    - ‚úÖ N√∫mero de d√≠a dentro del rango v√°lido
    - ‚úÖ No duplicar d√≠as ya existentes
    - ‚úÖ Consistencia con el plan padre
    
    **Estado Inicial:**
    - `is_published`: false (draft por defecto)
    - `published_at`: null hasta que se publique
    - Listo para agregar comidas con `POST /days/{daily_plan_id}/meals`
    
    **Ejemplo de Request:**
    ```json
    {
      "nutrition_plan_id": 123,
      "day_number": 1,
      "total_calories": 1800,
      "total_protein_g": 120,
      "total_carbs_g": 180,
      "total_fat_g": 80,
      "notes": "D√≠a de inicio - enfoque en hidrataci√≥n"
    }
    ```
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "id": 456,
      "nutrition_plan_id": 123,
      "day_number": 1,
      "total_calories": 1800,
      "total_protein_g": 120.0,
      "total_carbs_g": 180.0,
      "total_fat_g": 80.0,
      "notes": "D√≠a de inicio - enfoque en hidrataci√≥n",
      "is_published": false,
      "published_at": null,
      "created_at": "2024-01-15T10:00:00Z",
      "updated_at": "2024-01-15T10:00:00Z"
    }
    ```
    
    **Flujo de Trabajo del Creador:**
    1. **Crear Plan Base** ‚û°Ô∏è `POST /plans`
    2. **Agregar D√≠as** ‚û°Ô∏è `POST /plans/{id}/days` (repetir por cada d√≠a)
    3. **Agregar Comidas** ‚û°Ô∏è `POST /days/{id}/meals` (por cada comida del d√≠a)
    4. **Agregar Ingredientes** ‚û°Ô∏è `POST /meals/{id}/ingredients` (detalles de comidas)
    5. **Publicar D√≠a** ‚û°Ô∏è Cuando est√© completo y listo
    
    **Casos de Uso:**
    - üìù Creaci√≥n inicial de contenido del plan
    - ‚úèÔ∏è Estructuraci√≥n d√≠a por d√≠a del programa
    - üéØ Definici√≥n de metas nutricionales diarias
    - üìä Planificaci√≥n balanceada de macronutrientes
    
    **C√≥digos de Error:**
    - `400`: El plan_id del body no coincide con el path
    - `403`: Solo el creador puede agregar d√≠as al plan
    - `404`: Plan no encontrado o no pertenece al gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    # Verificar que el plan_id coincide
    if daily_plan_data.nutrition_plan_id != plan_id:
        raise HTTPException(status_code=400, detail="El plan_id no coincide")
    
    try:
        daily_plan = service.create_daily_plan(
            daily_plan_data=daily_plan_data,
            user_id=db_user.id
        )
        return daily_plan
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except PermissionError as e:
        raise HTTPException(status_code=403, detail=str(e))


@router.post("/days/{daily_plan_id}/meals", response_model=Meal)
def create_meal(
    meal_data: MealCreate,
    daily_plan_id: int = Path(..., description="ID del d√≠a al que agregar la comida"),
    db: Session = Depends(get_db),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    üçΩÔ∏è **Crear Comida en Plan Diario (Para Creadores)**
    
    **Descripci√≥n:**
    Permite a creadores agregar una comida espec√≠fica a un d√≠a de su plan nutricional.
    Cada comida representa una instancia alimentaria (desayuno, almuerzo, cena, etc.).
    
    **Proceso de Creaci√≥n:**
    1. **Validaci√≥n de Permisos:** Solo el creador del plan puede agregar comidas
    2. **Verificaci√≥n del D√≠a:** Valida que el d√≠a existe y pertenece al plan
    3. **Estructura Base:** Crea contenedor para los ingredientes de la comida
    4. **Informaci√≥n Nutricional:** Establece valores nutricionales base
    
    **Campos Requeridos:**
    - `meal_type`: Tipo de comida (breakfast, lunch, dinner, snack_morning, snack_afternoon, snack_evening)
    - `name`: Nombre descriptivo de la comida
    - `daily_plan_id`: Debe coincidir con el {daily_plan_id} del path
    
    **Campos Opcionales:**
    - `description`: Descripci√≥n detallada de la comida
    - `preparation_time_minutes`: Tiempo de preparaci√≥n estimado
    - `cooking_instructions`: Instrucciones paso a paso
    - `calories`, `protein_g`, `carbs_g`, `fat_g`: Valores nutricionales
    - `fiber_g`: Contenido de fibra
    - `image_url`: URL de imagen de la comida
    - `video_url`: URL de video de preparaci√≥n
    
    **Tipos de Comidas Disponibles:**
    - `breakfast`: Desayuno
    - `lunch`: Almuerzo  
    - `dinner`: Cena
    - `snack_morning`: Snack de media ma√±ana
    - `snack_afternoon`: Snack de media tarde
    - `snack_evening`: Snack nocturno
    
    **Validaciones Autom√°ticas:**
    - ‚úÖ Usuario es el creador del plan que contiene este d√≠a
    - ‚úÖ D√≠a existe y pertenece a un plan del gimnasio
    - ‚úÖ Tipo de comida v√°lido seg√∫n enum
    - ‚úÖ Valores nutricionales no negativos
    - ‚úÖ URLs v√°lidas para imagen y video
    
    **Estado Inicial:**
    - Lista para agregar ingredientes con `POST /meals/{meal_id}/ingredients`
    - Valores nutricionales se actualizan autom√°ticamente al agregar ingredientes
    - Visible para usuarios una vez que el d√≠a se publique
    
    **Ejemplo de Request:**
    ```json
    {
      "daily_plan_id": 456,
      "meal_type": "breakfast",
      "name": "Batido Verde Energ√©tico",
      "description": "Batido nutritivo con espinaca, pl√°tano y prote√≠na",
      "preparation_time_minutes": 5,
      "cooking_instructions": "1. Agregar espinaca al blender\\n2. A√±adir pl√°tano y prote√≠na\\n3. Licuar hasta obtener consistencia cremosa",
      "calories": 280,
      "protein_g": 25,
      "carbs_g": 35,
      "fat_g": 8,
      "fiber_g": 6,
      "image_url": "https://example.com/batido-verde.jpg"
    }
    ```
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "id": 789,
      "daily_plan_id": 456,
      "meal_type": "breakfast",
      "name": "Batido Verde Energ√©tico",
      "description": "Batido nutritivo con espinaca, pl√°tano y prote√≠na",
      "preparation_time_minutes": 5,
      "cooking_instructions": "1. Agregar espinaca al blender\\n2. A√±adir pl√°tano y prote√≠na\\n3. Licuar hasta obtener consistencia cremosa",
      "calories": 280,
      "protein_g": 25.0,
      "carbs_g": 35.0,
      "fat_g": 8.0,
      "fiber_g": 6.0,
      "image_url": "https://example.com/batido-verde.jpg",
      "video_url": null,
      "created_at": "2024-01-15T11:00:00Z",
      "updated_at": "2024-01-15T11:00:00Z"
    }
    ```
    
    **Flujo de Trabajo del Creador:**
    1. **Crear Plan** ‚û°Ô∏è `POST /plans`
    2. **Agregar D√≠as** ‚û°Ô∏è `POST /plans/{id}/days`
    3. **Agregar Comidas** ‚û°Ô∏è `POST /days/{id}/meals` (este endpoint)
    4. **Agregar Ingredientes** ‚û°Ô∏è `POST /meals/{id}/ingredients`
    5. **Revisar Totales** ‚û°Ô∏è Los valores nutricionales se actualizan autom√°ticamente
    
    **Mejores Pr√°cticas:**
    - üì∏ Incluir im√°genes atractivas para motivar a los usuarios
    - üé• Videos cortos para t√©cnicas de preparaci√≥n complejas
    - ‚è±Ô∏è Tiempo de preparaci√≥n realista para planificaci√≥n
    - üìù Instrucciones claras y paso a paso
    - üßÆ Valores nutricionales aproximados (se refinan con ingredientes)
    
    **Casos de Uso:**
    - üìù Creaci√≥n de contenido gastron√≥mico
    - üé® Dise√±o de experiencias culinarias
    - üìä Estructuraci√≥n de planes nutricionales
    - üç≥ Documentaci√≥n de recetas personalizadas
    
    **C√≥digos de Error:**
    - `400`: El daily_plan_id del body no coincide con el path
    - `403`: Solo el creador puede agregar comidas al plan
    - `404`: D√≠a no encontrado o no pertenece al gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    # Verificar que el daily_plan_id coincide
    if meal_data.daily_plan_id != daily_plan_id:
        raise HTTPException(status_code=400, detail="El daily_plan_id no coincide")
    
    try:
        meal = service.create_meal(
            meal_data=meal_data,
            user_id=db_user.id
        )
        return meal
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except PermissionError as e:
        raise HTTPException(status_code=403, detail=str(e))


@router.post("/meals/{meal_id}/ingredients", response_model=MealIngredient)
def add_ingredient_to_meal(
    ingredient_data: MealIngredientCreate,
    meal_id: int = Path(..., description="ID de la comida a la que agregar el ingrediente"),
    db: Session = Depends(get_db),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    ü•ï **Agregar Ingrediente a Comida (Para Creadores)**
    
    **Descripci√≥n:**
    Permite a creadores agregar ingredientes espec√≠ficos a una comida de su plan.
    Los ingredientes forman la base detallada de cada receta con informaci√≥n nutricional precisa.
    
    **Proceso de Agregado:**
    1. **Validaci√≥n de Permisos:** Solo el creador del plan puede agregar ingredientes
    2. **Verificaci√≥n de Comida:** Valida que la comida existe y pertenece al plan
    3. **C√°lculo Nutricional:** Procesa valores nutricionales por cantidad
    4. **Actualizaci√≥n Autom√°tica:** Recalcula totales de la comida y d√≠a
    
    **Campos Requeridos:**
    - `meal_id`: Debe coincidir con el {meal_id} del path
    - `name`: Nombre del ingrediente (ej: "Pollo pechuga", "Arroz integral")
    - `quantity`: Cantidad num√©rica (ej: 200, 1.5, 0.5)
    - `unit`: Unidad de medida (gr, ml, units, cups, tbsp, etc.)
    
    **Campos Opcionales:**
    - `calories_per_unit`: Calor√≠as por unidad especificada
    - `protein_g_per_unit`: Prote√≠na por unidad
    - `carbs_g_per_unit`: Carbohidratos por unidad
    - `fat_g_per_unit`: Grasas por unidad
    - `fiber_g_per_unit`: Fibra por unidad
    - `notes`: Notas especiales (ej: "org√°nico", "bajo en sodio")
    
    **Unidades de Medida Comunes:**
    - `gr`: Gramos (s√≥lidos)
    - `ml`: Mililitros (l√≠quidos)
    - `units`: Unidades (1 manzana, 2 huevos)
    - `cups`: Tazas
    - `tbsp`: Cucharadas
    - `tsp`: Cucharaditas
    - `oz`: Onzas
    
    **C√°lculo Autom√°tico:**
    - **Total Ingredient:** `quantity * valor_per_unit`
    - **Update Meal:** Suma todos los ingredientes
    - **Update Day:** Suma todas las comidas del d√≠a
    - **Consistency Check:** Verifica coherencia nutricional
    
    **Ejemplo de Request:**
    ```json
    {
      "meal_id": 789,
      "name": "Pollo pechuga sin piel",
      "quantity": 150,
      "unit": "gr",
      "calories_per_unit": 1.65,
      "protein_g_per_unit": 0.31,
      "carbs_g_per_unit": 0,
      "fat_g_per_unit": 0.036,
      "fiber_g_per_unit": 0,
      "notes": "Pollo de granja libre"
    }
    ```
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "id": 1234,
      "meal_id": 789,
      "name": "Pollo pechuga sin piel",
      "quantity": 150.0,
      "unit": "gr",
      "calories_per_unit": 1.65,
      "protein_g_per_unit": 0.31,
      "carbs_g_per_unit": 0.0,
      "fat_g_per_unit": 0.036,
      "fiber_g_per_unit": 0.0,
      "notes": "Pollo de granja libre",
      "total_calories": 247.5,
      "total_protein_g": 46.5,
      "total_carbs_g": 0.0,
      "total_fat_g": 5.4,
      "total_fiber_g": 0.0,
      "created_at": "2024-01-15T11:30:00Z",
      "updated_at": "2024-01-15T11:30:00Z"
    }
    ```
    
    **Validaciones Autom√°ticas:**
    - ‚úÖ Usuario es el creador del plan que contiene esta comida
    - ‚úÖ Comida existe y pertenece a un plan del gimnasio
    - ‚úÖ Cantidad es un valor positivo
    - ‚úÖ Unidad es v√°lida seg√∫n enum
    - ‚úÖ Valores nutricionales no negativos
    
    **Flujo de Trabajo del Creador:**
    1. **Crear Plan** ‚û°Ô∏è `POST /plans`
    2. **Agregar D√≠as** ‚û°Ô∏è `POST /plans/{id}/days`
    3. **Agregar Comidas** ‚û°Ô∏è `POST /days/{id}/meals`
    4. **Agregar Ingredientes** ‚û°Ô∏è `POST /meals/{id}/ingredients` (este endpoint)
    5. **Verificar Totales** ‚û°Ô∏è Los valores se actualizan autom√°ticamente
    
    **Mejores Pr√°cticas:**
    - üéØ **Precisi√≥n Nutricional:** Usar valores confiables (USDA, tablas oficiales)
    - üìè **Unidades Consistentes:** Mantener unidades l√≥gicas por tipo de alimento
    - üìù **Nombres Descriptivos:** Especificar tipo y preparaci√≥n
    - üîç **Notas √ötiles:** Incluir informaci√≥n relevante para usuarios
    - ‚öñÔ∏è **Porciones Realistas:** Cantidades apropiadas para el objetivo
    
    **Casos de Uso:**
    - üìä Precisi√≥n nutricional en recetas
    - üõí Generaci√≥n de listas de compras
    - üîÑ Sustituci√≥n de ingredientes
    - üìà An√°lisis de macronutrientes
    - üçΩÔ∏è Informaci√≥n detallada para usuarios
    
    **C√≥digos de Error:**
    - `400`: El meal_id del body no coincide con el path
    - `403`: Solo el creador puede agregar ingredientes
    - `404`: Comida no encontrada o no pertenece al gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    # Verificar que el meal_id coincide
    if ingredient_data.meal_id != meal_id:
        raise HTTPException(status_code=400, detail="El meal_id no coincide")
    
    try:
        ingredient = service.add_ingredient_to_meal(
            ingredient_data=ingredient_data,
            user_id=db_user.id
        )
        return ingredient
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except PermissionError as e:
        raise HTTPException(status_code=403, detail=str(e))


# ===== ENDPOINTS DE ANALYTICS =====

@router.get("/plans/{plan_id}/analytics", response_model=NutritionAnalytics)
def get_plan_analytics(
    plan_id: int = Path(..., description="ID del plan nutricional para analytics"),
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    üìä **Analytics del Plan Nutricional (Solo Creadores)**
    
    **Descripci√≥n:**
    Proporciona m√©tricas detalladas sobre el rendimiento y engagement de un plan nutricional.
    Exclusivo para creadores/entrenadores que desean analizar el √©xito de sus planes.
    
    **M√©tricas Principales:**
    
    **üìà Engagement:**
    - `total_followers`: N√∫mero total de usuarios que han seguido el plan
    - `active_followers`: Usuarios actualmente siguiendo el plan
    - `completion_rate`: Porcentaje promedio de completaci√≥n de comidas
    - `average_days_followed`: Promedio de d√≠as que los usuarios siguen el plan
    - `dropout_rate`: Porcentaje de usuarios que abandona el plan
    
    **‚≠ê Satisfacci√≥n:**
    - `average_satisfaction`: Rating promedio de satisfacci√≥n (1-5)
    - `satisfaction_distribution`: Distribuci√≥n de ratings
    - `most_popular_meals`: Comidas con mejores ratings
    - `least_popular_meals`: Comidas con peores ratings
    
    **üçΩÔ∏è Comportamiento de Comidas:**
    - `meal_completion_by_type`: Completaci√≥n por tipo (desayuno, almuerzo, etc.)
    - `meal_completion_by_day`: Completaci√≥n por d√≠a del plan
    - `peak_completion_hours`: Horas cuando m√°s se completan comidas
    - `photos_shared`: N√∫mero de fotos compartidas por usuarios
    
    **üìÖ An√°lisis Temporal:**
    - `daily_engagement`: Engagement d√≠a por d√≠a
    - `weekly_trends`: Tendencias semanales de actividad
    - `seasonal_patterns`: Patrones estacionales si aplicable
    - `retention_curve`: Curva de retenci√≥n de usuarios
    
    **üéØ Datos Espec√≠ficos por Tipo:**
    
    **Template Plans:**
    - An√°lisis de adopci√≥n individual
    - Patrones de inicio personalizados
    - M√©tricas de √©xito a largo plazo
    
    **Live Plans:**
    - An√°lisis de participaci√≥n grupal
    - Sincronizaci√≥n de actividad
    - M√©tricas de challenge grupal
    - Comparaci√≥n con otros live plans
    
    **Archived Plans:**
    - Datos hist√≥ricos preservados
    - Comparaci√≥n con performance original
    - M√©tricas de reutilizaci√≥n como template
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "plan_id": 123,
      "plan_title": "Challenge Detox 21 d√≠as",
      "plan_type": "live",
      "total_followers": 87,
      "active_followers": 23,
      "completion_rate": 78.5,
      "average_satisfaction": 4.2,
      "dropout_rate": 15.3,
      "meal_completion_by_type": {
        "breakfast": 85.2,
        "lunch": 78.9,
        "dinner": 71.4
      },
      "most_popular_meals": [
        {
          "meal_name": "Batido Verde",
          "satisfaction": 4.8,
          "completion_rate": 92.1
        }
      ],
      "daily_engagement": [
        {"day": 1, "completion_rate": 95.2},
        {"day": 2, "completion_rate": 89.1}
      ],
      "retention_curve": [
        {"day": 1, "active_users": 87},
        {"day": 7, "active_users": 78},
        {"day": 14, "active_users": 65}
      ]
    }
    ```
    
    **Permisos Estrictos:**
    - ‚úÖ Solo el creador/entrenador del plan puede ver analytics
    - ‚ùå Usuarios regulares no tienen acceso a estos datos
    - ‚ùå Otros entrenadores no pueden ver analytics de planes ajenos
    
    **Casos de Uso:**
    - üìä Evaluar √©xito de planes creados
    - üéØ Identificar √°reas de mejora
    - üìà Optimizar contenido futuro
    - üí° Inspiraci√≥n para nuevos planes
    - üèÜ Demostrar valor a clientes
    - üìù Reportes de rendimiento
    
    **Insights Accionables:**
    - **Alta Dropout:** Revisar dificultad o contenido
    - **Baja Satisfacci√≥n:** Mejorar recetas espec√≠ficas
    - **Patrones Temporales:** Optimizar timing de notificaciones
    - **Comidas Populares:** Replicar en futuros planes
    - **D√≠as Problem√°ticos:** Reforzar contenido espec√≠fico
    
    **Privacidad y √âtica:**
    - Datos agregados y anonimizados
    - Sin informaci√≥n personal identificable
    - Cumple con regulaciones de privacidad
    - Enfoque en mejora de contenido
    
    **C√≥digos de Error:**
    - `403`: Solo el creador puede ver analytics del plan
    - `404`: Plan no encontrado o no pertenece al gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        analytics = service.get_nutrition_analytics(
            plan_id=plan_id,
            user_id=db_user.id,
            gym_id=current_gym.id
        )
        return analytics
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except PermissionError as e:
        raise HTTPException(status_code=403, detail=str(e))


# ===== ENDPOINTS DE UTILIDAD =====

@router.get("/enums/goals")
def get_nutrition_goals():
    """
    üéØ **Objetivos Nutricionales Disponibles**
    
    Obtiene lista de objetivos nutricionales para filtrado y creaci√≥n de planes.
    Usado en formularios de creaci√≥n y filtros de b√∫squeda.
    
    **Objetivos Disponibles:**
    - `loss`: P√©rdida de peso
    - `gain`: Ganancia de peso
    - `bulk`: Volumen/masa muscular
    - `cut`: Definici√≥n muscular
    - `maintain`: Mantenimiento de peso
    
    **Formato de Respuesta:**
    ```json
    [
      {"value": "loss", "label": "Loss"},
      {"value": "gain", "label": "Gain"},
      {"value": "bulk", "label": "Bulk"},
      {"value": "cut", "label": "Cut"},
      {"value": "maintain", "label": "Maintain"}
    ]
    ```
    """
    return [{"value": goal.value, "label": goal.value.replace("_", " ").title()} 
            for goal in NutritionGoal]


@router.get("/enums/difficulty-levels")
def get_difficulty_levels():
    """
    ‚ö° **Niveles de Dificultad Disponibles**
    
    Obtiene lista de niveles de dificultad para clasificaci√≥n de planes.
    Ayuda a usuarios a encontrar planes apropiados para su experiencia.
    
    **Niveles Disponibles:**
    - `beginner`: Principiante (recetas simples, ingredientes b√°sicos)
    - `intermediate`: Intermedio (t√©cnicas moderadas, ingredientes diversos)
    - `advanced`: Avanzado (t√©cnicas complejas, ingredientes especializados)
    
    **Formato de Respuesta:**
    ```json
    [
      {"value": "beginner", "label": "Beginner"},
      {"value": "intermediate", "label": "Intermediate"},
      {"value": "advanced", "label": "Advanced"}
    ]
    ```
    """
    return [{"value": level.value, "label": level.value.title()} 
            for level in DifficultyLevel]


@router.get("/enums/budget-levels")
def get_budget_levels():
    """
    üí∞ **Niveles de Presupuesto Disponibles**
    
    Obtiene lista de niveles de presupuesto para filtrado econ√≥mico.
    Permite a usuarios encontrar planes dentro de su rango de gasto.
    
    **Niveles Disponibles:**
    - `low`: Bajo presupuesto (ingredientes econ√≥micos y accesibles)
    - `medium`: Presupuesto medio (balance entre calidad y precio)
    - `high`: Presupuesto alto (ingredientes premium y especializados)
    
    **Formato de Respuesta:**
    ```json
    [
      {"value": "low", "label": "Low"},
      {"value": "medium", "label": "Medium"},
      {"value": "high", "label": "High"}
    ]
    ```
    """
    return [{"value": level.value, "label": level.value.title()} 
            for level in BudgetLevel]


@router.get("/enums/dietary-restrictions")
def get_dietary_restrictions():
    """
    üö´ **Restricciones Diet√©ticas Disponibles**
    
    Obtiene lista de restricciones diet√©ticas para filtrado y personalizaci√≥n.
    Esencial para usuarios con necesidades alimentarias espec√≠ficas.
    
    **Restricciones Disponibles:**
    - `vegetarian`: Vegetariano (sin carne)
    - `vegan`: Vegano (sin productos animales)
    - `gluten_free`: Sin gluten
    - `dairy_free`: Sin l√°cteos
    - `keto`: Dieta cetog√©nica
    - `paleo`: Dieta paleol√≠tica
    - `low_carb`: Bajo en carbohidratos
    - `none`: Sin restricciones
    
    **Formato de Respuesta:**
    ```json
    [
      {"value": "vegetarian", "label": "Vegetarian"},
      {"value": "vegan", "label": "Vegan"},
      {"value": "gluten_free", "label": "Gluten Free"},
      {"value": "dairy_free", "label": "Dairy Free"}
    ]
    ```
    """
    return [{"value": restriction.value, "label": restriction.value.replace("_", " ").title()} 
            for restriction in DietaryRestriction]


@router.get("/enums/meal-types")
def get_meal_types():
    """
    üçΩÔ∏è **Tipos de Comidas Disponibles**
    
    Obtiene lista de tipos de comidas para creaci√≥n de contenido.
    Usado por creadores para estructurar d√≠as de planes nutricionales.
    
    **Tipos Disponibles:**
    - `breakfast`: Desayuno
    - `lunch`: Almuerzo
    - `dinner`: Cena
    - `snack_morning`: Snack de media ma√±ana
    - `snack_afternoon`: Snack de media tarde
    - `snack_evening`: Snack nocturno
    
    **Formato de Respuesta:**
    ```json
    [
      {"value": "breakfast", "label": "Breakfast"},
      {"value": "lunch", "label": "Lunch"},
      {"value": "dinner", "label": "Dinner"},
      {"value": "snack_morning", "label": "Snack Morning"}
    ]
    ```
    """
    return [{"value": meal_type.value, "label": meal_type.value.replace("_", " ").title()} 
            for meal_type in MealType]


@router.get("/enums/plan-types")
def get_plan_types():
    """
    üìã **Tipos de Planes Disponibles (Sistema H√≠brido)**
    
    Obtiene lista de tipos de planes del sistema h√≠brido.
    Fundamental para entender las opciones disponibles.
    
    **Tipos Disponibles:**
    - `template`: Plan individual, cada usuario inicia cuando quiere
    - `live`: Plan grupal sincronizado, fecha fija para todos
    - `archived`: Plan hist√≥rico, creado desde lives terminados
    
    **Formato de Respuesta:**
    ```json
    [
      {"value": "template", "label": "Template"},
      {"value": "live", "label": "Live"},
      {"value": "archived", "label": "Archived"}
    ]
    ```
    """
    return [{"value": plan_type.value, "label": plan_type.value.title()} 
            for plan_type in PlanType]


@router.get("/enums/plan-statuses")
def get_plan_statuses():
    """
    üìä **Estados de Planes Disponibles**
    
    Obtiene lista de estados posibles para planes nutricionales.
    Usado para filtrado y visualizaci√≥n de estado actual.
    
    **Estados Disponibles:**
    - `not_started`: No iniciado (plan live futuro o usuario no ha empezado)
    - `running`: En ejecuci√≥n (plan activo y usuario participando)
    - `finished`: Terminado (plan completado exitosamente)
    - `archived`: Archivado (plan live convertido a template)
    
    **Formato de Respuesta:**
    ```json
    [
      {"value": "not_started", "label": "Not Started"},
      {"value": "running", "label": "Running"},
      {"value": "finished", "label": "Finished"},
      {"value": "archived", "label": "Archived"}
    ]
    ```
    """
    return [{"value": status.value, "label": status.value.replace("_", " ").title()} 
            for status in PlanStatus]


# ===== NUEVOS ENDPOINTS DEL SISTEMA H√çBRIDO =====

@router.get("/plans/hybrid", response_model=NutritionPlanListResponseHybrid)
def list_plans_by_type(
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user),
    page: int = Query(1, ge=1, description="P√°gina para paginaci√≥n general"),
    per_page: int = Query(20, ge=1, le=100, description="Elementos por p√°gina"),
):
    """
    üîÄ **Lista de Planes Categorizados (Vista H√≠brida)**
    
    **Descripci√≥n:**
    Obtiene planes organizados por categor√≠as del sistema h√≠brido.
    Ideal para interfaces que necesitan mostrar planes separados por tipo.
    
    **Organizaci√≥n por Categor√≠as:**
    
    **üî¥ Live Plans (Challenges Grupales):**
    - Planes sincronizados con fecha fija
    - Todos los usuarios empiezan al mismo tiempo
    - Estado compartido entre participantes
    - Contador de participantes en tiempo real
    - Informaci√≥n de d√≠as hasta inicio
    
    **üìã Template Plans (Planes Individuales):**
    - Planes que cada usuario inicia cuando quiere
    - Progreso personal e independiente
    - Disponibles permanentemente
    - Estad√≠sticas de popularidad
    
    **üìö Archived Plans (Hist√≥ricos):**
    - Planes live exitosos convertidos a templates
    - Datos originales preservados
    - Informaci√≥n de performance hist√≥rica
    - Reutilizables como planes individuales
    
    **Informaci√≥n Espec√≠fica por Tipo:**
    
    **Para Live Plans:**
    - `live_participants_count`: Participantes actuales
    - `is_live_active`: Si est√° actualmente activo
    - `days_until_start`: D√≠as restantes hasta inicio
    - `status`: not_started, running, finished
    
    **Para Template Plans:**
    - `total_followers`: Total de usuarios que lo han seguido
    - `avg_satisfaction`: Rating promedio de satisfacci√≥n
    - `is_followed_by_user`: Si el usuario actual lo sigue
    
    **Para Archived Plans:**
    - `original_participants_count`: Participantes del live original
    - `archived_at`: Fecha de archivado
    - `original_live_plan_id`: ID del plan live original
    
    **Ejemplo de Respuesta:**
    ```json
    {
      "live_plans": [
        {
          "id": 123,
          "title": "Challenge Detox Enero",
          "plan_type": "live",
          "live_participants_count": 87,
          "is_live_active": true,
          "days_until_start": 0,
          "status": "running",
          "current_day": 5
        }
      ],
      "template_plans": [
        {
          "id": 456,
          "title": "Plan P√©rdida Peso 30 d√≠as",
          "plan_type": "template",
          "total_followers": 234,
          "avg_satisfaction": 4.2,
          "is_followed_by_user": false
        }
      ],
      "archived_plans": [
        {
          "id": 789,
          "title": "Challenge Verano Exitoso",
          "plan_type": "archived",
          "original_participants_count": 156,
          "archived_at": "2023-09-15T00:00:00Z",
          "total_followers": 45
        }
      ],
      "total": 3,
      "page": 1,
      "per_page": 20,
      "has_next": false,
      "has_prev": false
    }
    ```
    
    **Casos de Uso:**
    - üè† Pantalla principal con secciones separadas
    - üéØ Navegaci√≥n por tipo de experiencia deseada
    - üìä Dashboard administrativo categorizado
    - üîç Exploraci√≥n organizada de contenido
    - üì± Tabs o secciones en apps m√≥viles
    
    **Ventajas de esta Vista:**
    - **Claridad:** Separaci√≥n clara de tipos de planes
    - **Contexto:** Informaci√≥n relevante por categor√≠a
    - **UX:** Facilita decisi√≥n del usuario
    - **Performance:** Cargas optimizadas por tipo
    - **Filtrado:** Pre-filtrado autom√°tico
    
    **Limitaciones de Paginaci√≥n:**
    - Cada categor√≠a est√° limitada a 50 elementos m√°ximo
    - Paginaci√≥n general afecta el total combinado
    - Para listas extensas, usar endpoints espec√≠ficos por tipo
    
    **Comparaci√≥n con GET /plans:**
    - **GET /plans:** Lista unificada con filtros flexibles
    - **GET /plans/hybrid:** Vista categorizada pre-organizada
    - **Uso recomendado:** Hybrid para dashboards, /plans para b√∫squedas
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    # Obtener planes por tipo
    live_filters = NutritionPlanFilters(plan_type=PlanType.LIVE)
    template_filters = NutritionPlanFilters(plan_type=PlanType.TEMPLATE)
    archived_filters = NutritionPlanFilters(plan_type=PlanType.ARCHIVED)
    
    live_plans, live_total = service.list_nutrition_plans(
        gym_id=current_gym.id, filters=live_filters, page=1, per_page=50, user_id=db_user.id
    )
    
    template_plans, template_total = service.list_nutrition_plans(
        gym_id=current_gym.id, filters=template_filters, page=1, per_page=50, user_id=db_user.id
    )
    
    archived_plans, archived_total = service.list_nutrition_plans(
        gym_id=current_gym.id, filters=archived_filters, page=1, per_page=50, user_id=db_user.id
    )
    
    total = live_total + template_total + archived_total
    
    return NutritionPlanListResponseHybrid(
        live_plans=live_plans,
        template_plans=template_plans,
        archived_plans=archived_plans,
        total=total,
        page=page,
        per_page=per_page,
        has_next=(page * per_page) < total,
        has_prev=page > 1
    )


@router.put("/plans/{plan_id}/live-status", response_model=NutritionPlan)
def update_live_plan_status(
    plan_id: int = Path(...),
    status_update: LivePlanStatusUpdate = ...,
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    Actualizar el estado de un plan live (solo creadores).
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        # Verificar permisos
        plan = service.get_nutrition_plan(plan_id, current_gym.id)
        if plan.creator_id != db_user.id:
            raise HTTPException(status_code=403, detail="Solo el creador puede actualizar el estado del plan")
        
        if plan.plan_type != PlanType.LIVE:
            raise HTTPException(status_code=400, detail="Solo se puede actualizar el estado de planes live")
        
        # Actualizar estado
        plan.is_live_active = status_update.is_live_active
        if status_update.live_participants_count is not None:
            plan.live_participants_count = status_update.live_participants_count
        
        service.db.commit()
        service.db.refresh(plan)
        
        return plan
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.post("/plans/{plan_id}/archive", response_model=NutritionPlan)
def archive_live_plan(
    plan_id: int = Path(...),
    archive_request: ArchivePlanRequest = ...,
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    Archivar un plan live terminado (solo creadores).
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        archived_plan = service.archive_live_plan(
            plan_id=plan_id,
            user_id=db_user.id,
            gym_id=current_gym.id,
            archive_request=archive_request
        )
        return archived_plan
        
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except PermissionError as e:
        raise HTTPException(status_code=403, detail=str(e))


@router.get("/plans/{plan_id}/status")
def get_plan_status(
    plan_id: int = Path(..., description="ID del plan para obtener estado actual"),
    db: Session = Depends(get_db),
    current_gym: Gym = Depends(verify_gym_access),
    current_user: Auth0User = Depends(get_current_user)
):
    """
    üìä **Estado Actual del Plan (Informaci√≥n en Tiempo Real)**
    
    **Descripci√≥n:**
    Obtiene el estado actual detallado de un plan espec√≠fico para el usuario.
    Informaci√≥n din√°mica que se actualiza en tiempo real seg√∫n el tipo de plan.
    
    **Informaci√≥n de Estado Incluida:**
    
    **üìÖ Estado Temporal:**
    - `current_day`: D√≠a actual del plan (calculado seg√∫n tipo)
    - `status`: Estado actual (not_started, running, finished)
    - `days_until_start`: D√≠as restantes hasta inicio (solo para live futuros)
    
    **üîÑ Estado del Plan:**
    - `plan_type`: Tipo de plan (template, live, archived)
    - `is_live_active`: Si un plan live est√° actualmente activo
    - `live_participants_count`: N√∫mero actual de participantes (live plans)
    
    **üë§ Estado del Usuario:**
    - `is_following`: Si el usuario actual est√° siguiendo el plan
    - `user_start_date`: Cu√°ndo empez√≥ el usuario (si est√° siguiendo)
    - `user_progress`: Progreso personal del usuario
    
    **C√°lculo de `current_day` por Tipo:**
    
    **Template/Archived Plans:**
    ```
    current_day = d√≠as_desde_que_usuario_empez√≥ + 1
    Ejemplo: Usuario empez√≥ hace 14 d√≠as ‚Üí current_day = 15
    ```
    
    **Live Plans:**
    ```
    current_day = d√≠as_desde_fecha_global_del_plan + 1
    Ejemplo: Plan empez√≥ hace 4 d√≠as ‚Üí current_day = 5 (para todos)
    ```
    
    **Estados Posibles:**
    - **not_started**: Usuario no ha empezado o plan live futuro
    - **running**: Plan activo y usuario participando
    - **finished**: Plan completado (duraci√≥n alcanzada)
    
    **Ejemplo de Respuesta - Plan Live Activo:**
    ```json
    {
      "plan_id": 123,
      "plan_type": "live",
      "current_day": 5,
      "status": "running",
      "days_until_start": 0,
      "is_live_active": true,
      "live_participants_count": 87,
      "is_following": true,
      "user_start_date": "2024-01-10T00:00:00Z",
      "user_progress": {
        "meals_completed_today": 2,
        "total_meals_today": 3,
        "completion_percentage": 66.7
      }
    }
    ```
    
    **Ejemplo de Respuesta - Plan Live Futuro:**
    ```json
    {
      "plan_id": 456,
      "plan_type": "live",
      "current_day": 0,
      "status": "not_started",
      "days_until_start": 7,
      "is_live_active": false,
      "live_participants_count": 23,
      "is_following": true,
      "user_start_date": null
    }
    ```
    
    **Ejemplo de Respuesta - Template Plan:**
    ```json
    {
      "plan_id": 789,
      "plan_type": "template",
      "current_day": 12,
      "status": "running",
      "days_until_start": null,
      "is_live_active": null,
      "live_participants_count": null,
      "is_following": true,
      "user_start_date": "2024-01-03T00:00:00Z",
      "user_progress": {
        "total_days_completed": 11,
        "overall_completion_rate": 78.5
      }
    }
    ```
    
    **Actualizaciones Autom√°ticas:**
    - Estados de planes live se actualizan autom√°ticamente
    - Contadores de participantes en tiempo real
    - Verificaci√≥n de fechas de finalizaci√≥n
    - C√°lculo din√°mico de d√≠as transcurridos
    
    **Casos de Uso:**
    - üì± Widgets de estado en tiempo real
    - üîî Triggers para notificaciones
    - üìä Dashboards de progreso
    - üéØ L√≥gica condicional en frontend
    - ‚è∞ C√°lculo de elementos dependientes del tiempo
    
    **Optimizaci√≥n:**
    - Endpoint ligero optimizado para llamadas frecuentes
    - C√°lculos eficientes en tiempo real
    - Datos m√≠nimos necesarios para estado
    - Cache-friendly para polling
    
    **Permisos:**
    - ‚úÖ Cualquier usuario puede ver estado de planes p√∫blicos
    - üîí Planes privados solo creador y seguidores
    - üìä Informaci√≥n de progreso solo para seguidores
    
    **C√≥digos de Error:**
    - `403`: Sin acceso a plan privado
    - `404`: Plan no encontrado o no pertenece al gimnasio
    """
    service = NutritionService(db)
    
    # Obtener usuario local
    db_user = user_service.get_user_by_auth0_id(db, auth0_id=current_user.id)
    if not db_user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    try:
        plan = service.get_nutrition_plan(plan_id, current_gym.id)
        
        # Obtener informaci√≥n de seguimiento del usuario
        follower = None
        if db_user.id != plan.creator_id:
            from app.models.nutrition import NutritionPlanFollower
            follower = service.db.query(NutritionPlanFollower).filter(
                NutritionPlanFollower.plan_id == plan_id,
                NutritionPlanFollower.user_id == db_user.id,
                NutritionPlanFollower.is_active == True
            ).first()
        
        # Calcular estado
        current_day, status = service.get_current_plan_day(plan, follower)
        days_until_start = service.get_days_until_start(plan)
        
        # Actualizar estado de planes live
        if plan.plan_type == PlanType.LIVE:
            plan = service.update_live_plan_status(plan.id, current_gym.id)
        
        return {
            "plan_id": plan.id,
            "plan_type": plan.plan_type,
            "current_day": current_day,
            "status": status,
            "days_until_start": days_until_start,
            "is_live_active": plan.is_live_active,
            "live_participants_count": plan.live_participants_count,
            "is_following": follower is not None
        }
        
    except NotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e)) 